package me.ai.training.config;

import me.ai.training.weather.Weather;
import me.ai.training.weather.WeatherApiService;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.prompt.ChatOptions;
import org.springframework.ai.openai.OpenAiChatOptions;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Description;
import org.springframework.web.client.RestClient;

import java.util.function.Function;

/**
 * @author Rohit Muneshwar
 */
@Configuration
public class ApplicationConfig {
    @Bean
    RestClient restClient(){
        return RestClient.create();
    }

    @Bean
    ChatClient chatClient(ChatClient.Builder builder){
        return builder.build();
    }

    // FunctionCalling:: Register this function here so that it can be used by LLM
    @Bean
    @Description("Get the weather of the city")
    Function<Weather.Request, Weather.Response> currentWeather(){
        return new WeatherApiService();
    }

    /**
     * Recommendation:
     * Temperature = 0.6 - balanced
     * Maxtokens = 200 - controlled response size
     * topP = 0.9 - good vocabulary
     * frequencyPenalty - 0.4 - avoids repetition
     * presencePenalty - 0.2 - introduce new
     * @return
     */
    @Bean
    ChatOptions openAiChatOptions(){
        // provide OpenAI chat options: controls the response generated by the AI
        return OpenAiChatOptions.builder()
                // creativity(1.5) vs predictability(0.0)
                .temperature(0.7)
                // words+punctuations -> maximum length of response.
                // too high -> cost + latency
                .maxTokens(50)
                // nucleus sampling - controls word choices
                // default - 0.9 -> considers top 90% probability words
                // 1.0 -> considers all possible words
                // 0.5 -> very narrow, safe words only
                .topP(0.9)
                // control repetition of same words.
                // high frequency means less repetition.
                // 0.3 to 0.6 for explanation
                .frequencyPenalty(0.4)
                // encourage with new topics/ideas - control repetition of same concepts.
                // high -> new ideas
                /**
                 * Prompt: Explain Java
                 * PresencePenalty = 0.0 - basics of Java
                 * PresencePenalty= 0.2 (default) - new features of Java
                 */
                .presencePenalty(0.2)
                .build();
    }
}
